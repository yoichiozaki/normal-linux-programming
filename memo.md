# ストリームに関わるシステムコール

- `read`
	- ストリームからバイト列を読み込む
- `write`
	- ストリームにバイト列を書き込む
- `open`
	- ストリームを作る
- `close`
	- ストリームを捨てる

## ファイルディスクリプタ
カーネル内ではストリームを管理するデータ構造を持っていて、プロセスからは直接ストリームを扱うことはせずに、整数値の番号で指定する形をとる。その番号のことをファイルディスクリプタという。「ファイルディスクリプタ1のストリーム」と叫ぶと該当するストリームを指定できる感じ。

- 標準入力`STDIN_FILENO` = `0`
- 標準出力`STDOUT_FILENO` = `1`
- 標準入力`STDERR_FILENO` = `2`

「標準」の意味するところは「そのプロセスにとってのデフォルト」に近い意味。

パイプで入口出口をストリームでつなげることができる。

標準エラー出力がある理由: 標準入出力はつなげることがある。手前のコマンドの標準出力が次のコマンドの標準入力になっていることがある。エラーをそのまま標準出力に吐いていると次のコマンドが食っちゃう。これを避けるための標準エラー出力。

プログラムに読ませたい内容は標準出力から出す。
人間に読ませたい内容は標準エラー出力から出す。

## ストリームの読み書き

### `read`

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t bufsize);
```

> `ssize_t`と`size_t`は`sys/types.h`で定義されている型で、中身はただの整数型の別名。`int`とか`long`とかと変わらない。独自の型を定義することでマシンやカーネルのバージョン違いなどに関わらず同じソースコードを使えるようにすることができる。

`read`は

- ファイルディスクリプタ`fd`番で指定されるストリームからバイト列を読み込むシステムコール。
- 最大で`bufsize`だけ読み込み、読み込み結果を`buf`に格納する。
- 返り値は、
	- 読み込みが正常に終了した場合は、`読んだバイト数`
	- ファイル終端に達した時は`0`
	- エラーが起きた時は`-1`
- 終端文字`'\0'`を期待しないAPI

### `write`

```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t bufsize);
```

> `ssize_t`と`size_t`は`sys/types.h`で定義されている型で、中身はただの整数型の別名。`int`とか`long`とかと変わらない。独自の型を定義することでマシンやカーネルのバージョン違いなどに関わらず同じソースコードを使えるようにすることができる。

`write`は

- ファイルディスクリプタ`fd`番で指定されるストリームにバイト列を書き込むシステムコール。
- `bufsize`だけ書き込む。
- 返り値は、
	- 書き込みが正常に終了した場合は、`書いたバイト数`
	- エラーが起きた時は`-1`
- 全部書き込めないこともあるかもしれないので返り値は確認するべし。

## ファイルを開く・閉じる
### `open`

```c
#include <sys/types.h>
#include <sys.stat.h>
#include <fcntl.h>

int open(const char *path, int flags);
int open(const char *path, int flags, mode_t mode);
```

`open`は

- `path`で特定されるファイルに繋がるストリームを作成し、そのストリームを指すファイルディスクリプタ（ただの`int`）を返すシステムコール。
- `flags`で作成するストリームの性質を決定することができる。
	- `O_RDONLY`: 読み込み専用
	- `O_WRONLY`: 書き込み専用
	- `O_RDWR`: 読み書き両用


### `close`

```c
#include <unistd.h>

int close(int fd);
```

`close`は

- ファイルディスクリプタ`fd`で特定されるストリームを閉じるシステムコール。
- 返り値は	
	- 問題なく閉じることができたら`0`
	- エラーが発生したら`-1`

典型的な使い方: 

```c
if (close(fd) < 0) {
	// handling error
}
```

## ファイルオフセット
ストリームはファイルに対して、「ファイルオフセットの位置に繋がっている」と言える。なぜなら、同一のファイルディスクリプタで特定されるストリームに対して何度も`read`を呼ぶと、必ず前回の呼び出しの続きが帰ってくる。


### `lseek`
`lseek`はファイルオフセットの位置を変えるシステムコール。

```c
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

### `dup`/`dup2`
ファイルディスクリプタの複製を行うシステムコール。

```c
#include <unistd.h>

int dup(int oldfc);
int dup2(int oldfd, int newfd);
```

### `ioctl`
ストリームで繋がるデバイスに特化した操作を全て含むシステムコール。要するに`read`/`write`/`open`/`close`以外に必要なシステムコールをまとめたもの。しわ寄せ。

```c
#include <unistd.h>
// unistd stands for UNIx STanDard.

int ioctl(int fd, unsign long request, ...);
```

可変長引数をとる。
`request`で操作を定数で指定する。定数は`sys/ioctl.h`に定義されている。

### `fcntl`
ファイルディスクリプタ関連の操作を`ioctl`から分離しようとした。

```c
#include <unistd.h>
#include <fcntl.h>

int fcntl(inf fd, int cmd, ...);
```

要するにファイルディスクリプタに対する操作をこの関数で一手に引き受けようとした。操作内容は`cmd`で指定する。

`fcntl(fd, F_DUPFD)` == `dup(fd)`ということ。